<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="cpp," />










<meta name="description" content="拷贝控制操作：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符、析构函数。如果一个类没有对定义所有这些拷贝控制成员，编译器将自动为它定义缺失的操作（移动构造缺失时不一定会定义） 学习到以下内容：  编译器对这些操作默认定义是怎样的？  什么时候会调用这些操作  怎样定义这些拷贝控制操作  怎样写行为像指针的类和行为像值的类  怎么写一个动态内存类，以vector 为例  利用移动操作和右">
<meta property="og:type" content="article">
<meta property="og:title" content="c++ 学习笔记系列--拷贝控制">
<meta property="og:url" content="http://yoursite.com/2020/06/21/c++%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97--%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/index.html">
<meta property="og:site_name" content="容文滔">
<meta property="og:description" content="拷贝控制操作：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符、析构函数。如果一个类没有对定义所有这些拷贝控制成员，编译器将自动为它定义缺失的操作（移动构造缺失时不一定会定义） 学习到以下内容：  编译器对这些操作默认定义是怎样的？  什么时候会调用这些操作  怎样定义这些拷贝控制操作  怎样写行为像指针的类和行为像值的类  怎么写一个动态内存类，以vector 为例  利用移动操作和右">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-06-21T14:54:43.845Z">
<meta property="article:modified_time" content="2020-06-21T14:54:43.845Z">
<meta property="article:author" content="Wentao Yung">
<meta property="article:tag" content="cpp">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/06/21/c++ 学习笔记系列--拷贝控制/"/>





  <title>c++ 学习笔记系列--拷贝控制 | 容文滔</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">容文滔</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/21/c++%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97--%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wentao Yung">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="容文滔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">c++ 学习笔记系列--拷贝控制</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-21T22:54:43+08:00">
                2020-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index">
                    <span itemprop="name">c++</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/" itemprop="url" rel="index">
                    <span itemprop="name">拷贝控制</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>拷贝控制操作：<strong>拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符、析构函数</strong>。如果一个类没有对定义所有这些拷贝控制成员，编译器将自动为它定义缺失的操作（移动构造缺失时不一定会定义）</p>
<p>学习到以下内容：</p>
<ul>
<li><p>编译器对这些操作默认定义是怎样的？</p>
</li>
<li><p>什么时候会调用这些操作</p>
</li>
<li><p>怎样定义这些拷贝控制操作</p>
</li>
<li><p>怎样写行为像指针的类和行为像值的类</p>
</li>
<li><p>怎么写一个动态内存类，以vector<string> 为例</string></p>
</li>
<li><p>利用移动操作和右值引用来减少不必要的拷贝</p>
</li>
</ul>
<p>代码：<a href="https://github.com/WenTao-Rong/CppNote/tree/master/copy_control" target="_blank" rel="noopener">https://github.com/WenTao-Rong/CppNote/tree/master/copy_control</a></p>
<p>参考书籍：c++ primer</p>
<a id="more"></a>

<h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><h5 id="合成拷贝构造函数"><a href="#合成拷贝构造函数" class="headerlink" title="合成拷贝构造函数"></a>合成拷贝构造函数</h5><p>合成拷贝构造函数（合成指编译器生成）及其拷贝方式：</p>
<p>对类类型的成员，使用其拷贝构造函数来拷贝，内置类型的成员则直接拷贝；数组会逐一直接拷贝（内置类型成员）或调用拷贝构造函数（类类型成员）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sale_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Sale_data(<span class="built_in">string</span> book,intunits,doublereven)</span><br><span class="line">        :bookNo(book),units_sold(units),revenue(reven)&#123;&#125;;</span><br><span class="line">    Sale_data(<span class="keyword">const</span> Sale_data &amp; org):</span><br><span class="line">    bookNo(org.bookNo),units_sold(org.units_sold),revenue(org.revenue)&#123;&#125;<span class="comment">//等价合成拷贝构造函数，注释后效果一样</span></span><br><span class="line">    Sale_data &amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> Sale_data &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        bookNo=rhs.bookNo;</span><br><span class="line">        units_sold=rhs.units_sold;</span><br><span class="line">        revenue=rhs.revenue;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;<span class="comment">//等价合成拷贝赋值运算符，注释后效果一样</span></span><br><span class="line">    ~Sale_data()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Sale_data deconstruct"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"bookno: "</span>&lt;&lt;bookNo&lt;&lt;<span class="string">" unit_sold: "</span>&lt;&lt;units_sold&lt;&lt;<span class="string">" revenue: "</span>&lt;&lt;revenue&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">int</span> units_sold=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue=<span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Sale_data <span class="title">s1</span><span class="params">(<span class="string">"bookk"</span>,<span class="number">5</span>,<span class="number">9.34</span>)</span></span>;</span><br><span class="line">    Sale_data s2=s1;</span><br><span class="line">    s2.<span class="built_in">print</span>();</span><br><span class="line">    <span class="function">Sale_data <span class="title">s3</span><span class="params">(s1)</span></span>;</span><br><span class="line">    s3.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="拷贝初始化"><a href="#拷贝初始化" class="headerlink" title="拷贝初始化"></a>拷贝初始化</h5><p>拷贝初始化需要用拷贝构造函数或移动构造来完成</p>
<p>拷贝初始化：使用等号初始化一个变量</p>
<p>直接初始化：不使用等号初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="number">10</span>,<span class="string">'.'</span>)</span></span>;<span class="comment">//直接初始化</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s2</span><span class="params">(s)</span></span>;<span class="comment">//直接初始化</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s3=<span class="string">"string"</span>;<span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s4=<span class="built_in">string</span>(<span class="number">10</span>,<span class="string">'9'</span>);<span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s5=s4;<span class="comment">//拷贝初始化</span></span><br></pre></td></tr></table></figure>

<p>拷贝初始化不仅在用=定义变量时发生，在以下情况也会发生：</p>
<ul>
<li>传递对象给非引用类型的形参</li>
<li>返回一个非引用的类型的对象</li>
<li>用花括号初始化数组或聚合类的成员</li>
</ul>
<h5 id="拷贝构造函数的形参"><a href="#拷贝构造函数的形参" class="headerlink" title="拷贝构造函数的形参"></a>拷贝构造函数的形参</h5><p>必须是引用类型参数，否则调用会无限循环</p>
<h4 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h4><p>合成拷贝赋值运算符见上Sale_data类,注意返回值是引用类型</p>
<h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p>析构函数不接受参数，因此不能被重载</p>
<h5 id="析构函数的工作"><a href="#析构函数的工作" class="headerlink" title="析构函数的工作"></a>析构函数的工作</h5><p>先执行函数体，在销毁成员，成员按初始化的逆序销毁。</p>
<p>销毁类成员需要执行成员自身的析构函数，内置类型没有析构函数，因此销毁内置成员什么都不用做</p>
<h5 id="什么时候调用析构函数"><a href="#什么时候调用析构函数" class="headerlink" title="什么时候调用析构函数"></a>什么时候调用析构函数</h5><p>对象被销毁，就会自动调用析构函数：</p>
<ul>
<li>变量离开作用域被销毁</li>
<li>当对象被销毁时，其成员被销毁</li>
<li>容器被销毁时，其元素被销毁</li>
<li>动态分配的对象，使用delete销毁</li>
<li>临时对象，当创建完它的完整表达式结束时被销毁</li>
</ul>
<p>当一个对象的指针或引用离开作用域，析构函数不会执行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Sale_data * p=<span class="keyword">new</span> Sale_data(<span class="string">"book1"</span>,<span class="number">23</span>,<span class="number">4.3</span>);</span><br><span class="line"><span class="keyword">auto</span> p2=make_shared&lt;Sale_data&gt;(<span class="string">"book2"</span>,<span class="number">45</span>,<span class="number">9.3</span>);</span><br><span class="line"><span class="function">Sale_data <span class="title">item</span><span class="params">(*p)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;Sale_data&gt; vec;</span><br><span class="line">vec.push_back(*p2);</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数将执行4次</span></span><br></pre></td></tr></table></figure>

<h5 id="合成析构函数"><a href="#合成析构函数" class="headerlink" title="合成析构函数"></a>合成析构函数</h5><p>如果未定义类的析构函数，编译器会定义一个合成析构函数，它的函数体是空的，但析构函数体执行完后，成员会自动被销毁，比如Sale_data的string 成员的析构函数就被调用，但动态内存需要调用delete或者借助智能指针</p>
<h4 id="三-五法则"><a href="#三-五法则" class="headerlink" title="三/五法则"></a>三/五法则</h4><p>需要析构函数的类也需要拷贝构造和拷贝赋值操作，比如没有定义拷贝构造和拷贝赋值操作，下面程序会出错</p>
<p>拷贝构造和拷贝赋值共存</p>
<p>5个拷贝控制成员看做一个整体，如果一个类定义任意一个拷贝操作，它应该定义所有5个操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>  &amp; s=<span class="built_in">std</span>::<span class="built_in">string</span>()):ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)),i(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    ~HasPtr()&#123;<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"~HasPtr()"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="keyword">delete</span> ps;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"*ps"</span>&lt;&lt;*ps&lt;&lt;<span class="string">" i="</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">HasPtr <span class="title">f</span><span class="params">(HasPtr hp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HasPtr ret=hp;<span class="comment">//执行合成拷贝赋值操作，res的ps和hp的ps相同的指针值</span></span><br><span class="line">    <span class="keyword">return</span> ret;<span class="comment">//hp和ret离开作用域后执行析构函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">HasPtr <span class="title">p</span><span class="params">(<span class="string">"some value"</span>)</span></span>;</span><br><span class="line">    f(p);</span><br><span class="line">    <span class="function">HasPtr <span class="title">q</span><span class="params">(p)</span></span>;</span><br><span class="line">    q.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-default-和-delete"><a href="#使用-default-和-delete" class="headerlink" title="使用=default 和=delete"></a>使用=default 和=delete</h4><p>使用=default(只能对默认构造函数和拷贝控制成员使用)， 在类内修饰成员的声明时，合成的函数为内联函数，在类外修饰，不是内联函数</p>
<p>=delete 用来阻止拷贝 (对任何函数也可以使用，析构函数不可以)，必须出现在函数第一次声明的地方</p>
<h4 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h4><h5 id="行为像值的类"><a href="#行为像值的类" class="headerlink" title="行为像值的类"></a>行为像值的类</h5><p>每个对象都有一个拷贝</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>  &amp; s=<span class="built_in">std</span>::<span class="built_in">string</span>()):ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)),i(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    ~HasPtr()&#123;<span class="keyword">delete</span> ps;&#125;</span><br><span class="line">    HasPtr(<span class="keyword">const</span> HasPtr&amp; p):ps(<span class="keyword">new</span> <span class="built_in">string</span>(*p.ps)),i(p.i)&#123;&#125;;</span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> HasPtr&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span>*  newp=<span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps);</span><br><span class="line">        <span class="keyword">delete</span> ps;</span><br><span class="line">        ps=newp;</span><br><span class="line">        i=rhs.i;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"*ps= "</span>&lt;&lt;*ps&lt;&lt;<span class="string">" i="</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类值拷贝赋值运算符</p>
<p>要防范自我赋值的情况，编写一个拷贝赋值运算符的模式是先将右侧运算符对象拷贝到一个局部临时对象中，然后销毁左侧运算对象的现有成员，最后将临时对象拷贝到左侧运算符对象的成员里</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> HasPtr&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    ps=<span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps);</span><br><span class="line">    ps.i=rhs.i;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="comment">//错误写法</span></span><br></pre></td></tr></table></figure>

<h5 id="行为像指针的类"><a href="#行为像指针的类" class="headerlink" title="行为像指针的类"></a>行为像指针的类</h5><p>使用引用计数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>  &amp; s=<span class="built_in">std</span>::<span class="built_in">string</span>()):ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)),i(<span class="number">0</span>),use(<span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>))&#123;&#125;;</span><br><span class="line">    ~HasPtr()&#123;</span><br><span class="line">        <span class="keyword">if</span>(--*use==<span class="number">0</span>) &#123;<span class="keyword">delete</span> ps;<span class="keyword">delete</span> use;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    HasPtr(<span class="keyword">const</span> HasPtr&amp; p):ps(p.ps),i(p.i)&#123;++*use;&#125;</span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> HasPtr&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        ++*rhs.use;<span class="comment">//先增加右操作数的引用个数，自赋值安全</span></span><br><span class="line">        <span class="keyword">if</span>(--*use==<span class="number">0</span>) &#123;<span class="keyword">delete</span> ps;<span class="keyword">delete</span> use;&#125;</span><br><span class="line">        ps=rhs.ps;</span><br><span class="line">        i=rhs.i;</span><br><span class="line">        use=rhs.use;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"*ps= "</span>&lt;&lt;*ps&lt;&lt;<span class="string">" i="</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">size_t</span> *use;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h4><p>swap 不是必要的，但对于分配了资源的类，定义swap可能是重要的优化手段</p>
<p>如果一个类没有定义swap，使用到swap的算法将使用标准库定义的swap,例如交换HasPtr对象（HasPtr是一个行为像值的类）的代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HasPtr temp=v1;</span><br><span class="line">v1=v2;</span><br><span class="line">v2=temp;<span class="comment">//这样产生不必要的内存分配</span></span><br></pre></td></tr></table></figure>

<p>在HasPtr中编写自己的swap函数并且在赋值运算中使用swap</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>  &amp; s=<span class="built_in">std</span>::<span class="built_in">string</span>()):ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)),i(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    ~HasPtr()&#123;<span class="keyword">delete</span> ps;&#125;</span><br><span class="line">    HasPtr(<span class="keyword">const</span> HasPtr&amp; p):ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*p.ps)),i(p.i)&#123;&#125;</span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span> =(HasPtr rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(*<span class="keyword">this</span>,rhs);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;<span class="comment">//参数rhs不是引用，离开作用域后，rhs(this原来的内容)被析构了，this指向新创建的副本内容，能处理自赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp; lhs,HasPtr &amp;rhs)</span></span>;<span class="comment">//声明为友员函数，是为了能访问私有成员</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"*ps= "</span>&lt;&lt;*ps&lt;&lt;<span class="string">" i="</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp; lhs,HasPtr &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;<span class="comment">//使用std的swap</span></span><br><span class="line">    swap(lhs.ps,rhs.ps);</span><br><span class="line">    swap(lhs.i,rhs.i);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="动态内存管理类"><a href="#动态内存管理类" class="headerlink" title="动态内存管理类"></a>动态内存管理类</h4><p>实现一个简化版的vector类，而且只用于string</p>
<p>在重分配内存函数reallocate中，为了避免不必要的拷贝且旧空间的数据不再使用，调用move得到右值引用从而使用string的移动构造函数，而已标准库保证‘“移后源”string保持一个有效的，可析构的状态</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    StrVec():elements(<span class="literal">nullptr</span>),cap(<span class="literal">nullptr</span>),first_free(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">    ~StrVec()&#123;</span><br><span class="line">        <span class="built_in">free</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    StrVec(<span class="keyword">const</span> StrVec&amp; s)</span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="keyword">auto</span> data=alloc_n_copy(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        elements=data.first;</span><br><span class="line">        first_free=cap=data.second;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    StrVec&amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> StrVec &amp;s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> data=alloc_n_copy(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">free</span>();</span><br><span class="line">        elements=data.first;</span><br><span class="line">        first_free=cap=data.second;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        check_alloc();</span><br><span class="line">        alloc.construct(first_free++,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> first_free-elements;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> cap-elements;&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span>* <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> elements;&#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span>* <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> first_free;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    std::pair&lt;std::string* ,std::string*&gt;  alloc_n_copy(const std::string * begin,const  std::string * end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> data=alloc.allocate(<span class="built_in">end</span>-<span class="built_in">begin</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123;data,uninitialized_copy(<span class="built_in">begin</span>,<span class="built_in">end</span>,data)&#125;;</span><br><span class="line">        <span class="comment">//uninitialized_copy从begin开始到end拷贝元素到data指定的未构造的内存中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reallocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newcapcity=<span class="built_in">size</span>()?<span class="number">2</span>*<span class="built_in">size</span>():<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> * newdata=alloc.allocate(newcapcity);</span><br><span class="line">        <span class="comment">//allocate函数，创建未构造的，原始的内存</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span>* dest=newdata;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span>* elem=elements;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            alloc.construct(dest++,<span class="built_in">std</span>::<span class="built_in">move</span>(*elem++));</span><br><span class="line">            <span class="comment">//construct函数 在未构造的内存构造对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>();</span><br><span class="line">        elements=newdata;</span><br><span class="line">        first_free=dest;</span><br><span class="line">        cap=newdata+newcapcity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">check_alloc</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(<span class="built_in">size</span>()==capacity()) reallocate();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(elements)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> p=first_free;p!=elements;p--)</span><br><span class="line">                alloc.destroy(p);<span class="comment">//destroy函数对p指向的对象执行析构函数</span></span><br><span class="line">            alloc.deallocate(elements,cap-elements);<span class="comment">//deallocate释放从elements开始的cap-elements个对象的内存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *elements;<span class="comment">//指向分配的内存的首元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *cap;<span class="comment">//指向分配的内存末尾之后的位置</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *first_free;<span class="comment">//指向最后一个元素之后的位置</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::allocator&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; alloc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::allocator&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; StrVec::alloc;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StrVec p;</span><br><span class="line">    p.push_back(<span class="string">"string1"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;p.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    p.push_back(<span class="string">"string2"</span>);</span><br><span class="line">    p.push_back(<span class="string">"string2"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;p.capacity()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">StrVec <span class="title">p2</span><span class="params">(p)</span></span>;</span><br><span class="line">    StrVec p3=p2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;p2.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;p3.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="移动对象"><a href="#移动对象" class="headerlink" title="移动对象"></a>移动对象</h4><h5 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h5><p>右值引用是必须绑定到右值的引用，通过&amp;&amp;获取右值引用，右值引用只能绑定到一个将要销毁的对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r=i;<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr=i;<span class="comment">//错误</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2=i*<span class="number">42</span>;<span class="comment">//错误</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3=i*<span class="number">42</span>;<span class="comment">//正确，可以一个const的引用绑定到一个右值上</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp; rr2=i*<span class="number">42</span>;<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr1=<span class="number">42</span>;<span class="comment">///正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr3=rr1;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>返回左值引用的函数，连同赋值、下标、前置递增/递减，都是返回左值的表达式的例子</p>
<p>返回非引用类型的函数，连同算术、关系、后置递增/递减，都生成右值。不能将左值引用绑定到右值上，但可以用const的左值引用或右值引用绑定。</p>
<p>左值持久，右值短暂</p>
<h5 id="标准库move-函数"><a href="#标准库move-函数" class="headerlink" title="标准库move 函数"></a>标准库move 函数</h5><p>通过move函数可以获取绑定到左值上的右值引用,但是调用move意味承诺除了赋值或销毁这个左值外，我们不再使用它</p>
<p>move函数可以接受右值和左值</p>
<h5 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h5><p>移动构造函数不仅完成资源移动，而且必须确保移后源对象处于一种状态-销毁它是无害的。也就是说资源完成移动后，原对象不能再指向被移动的资源。可以通过将移后源对象的指针成员置为nullptr实现</p>
<p>另外移动构造函数和移动赋值运算符不应抛出任何异常，所以类的头文件和定义都要指定noexcept，因为移动构造抛出异常时，不安全的，指定noexcept就是告诉编译器我们的移动构造是安全的，否则编译器就必须使用拷贝构造</p>
<p>我们实现StrVec的移动构造函数和移动赋值运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">StrVec(StrVec&amp;&amp; s) <span class="keyword">noexcept</span>:elements(s.elements),cap(s.cap),first_free(s.first_free)</span><br><span class="line">&#123;</span><br><span class="line">    s.elements=s.first_free=s.cap=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">StrVec&amp; <span class="keyword">operator</span>= (StrVec&amp;&amp; rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>!=&amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>();</span><br><span class="line">        elements=rhs.elements;</span><br><span class="line">        first_free=rhs.first_free;</span><br><span class="line">        cap=rhs.cap;</span><br><span class="line">        rhs.elements=rhs.first_free=rhs.cap=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合成的移动构造函数和移动赋值运算符"><a href="#合成的移动构造函数和移动赋值运算符" class="headerlink" title="合成的移动构造函数和移动赋值运算符"></a>合成的移动构造函数和移动赋值运算符</h5><p>如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或析构函数，编译器不会合成移动操作。如果没有移动操作，类会使用拷贝操作代替移动操作。</p>
<p>只有一个类没有定义任何自己版本的拷贝控制成员，且每个类非static数据成员都可以移动时，编译器才合成移动构造函数和移动赋值运算符</p>
<p>定义了一个移动构造函数或移动赋值运算符的类一定也定义自己的拷贝操作，否则移动操作默认地被定义为删除的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hasX</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        X men;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        X x;</span><br><span class="line">        x.i=<span class="number">10</span>;</span><br><span class="line">        x.s=<span class="string">"string"</span>;</span><br><span class="line">        X x2=<span class="built_in">std</span>::<span class="built_in">move</span>(x);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"x: "</span>&lt;&lt;x.s&lt;&lt;<span class="string">" x2:"</span>&lt;&lt;x2.s&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//仅用来验证是否调用了移动构造函数</span></span><br><span class="line">        hasX hx,hx2=<span class="built_in">std</span>::<span class="built_in">move</span>(hx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="什么时候调用移动构造函数和移动赋值运算符"><a href="#什么时候调用移动构造函数和移动赋值运算符" class="headerlink" title="什么时候调用移动构造函数和移动赋值运算符"></a>什么时候调用移动构造函数和移动赋值运算符</h5><ol>
<li>类都有移动构造和拷贝构造函数：</li>
</ol>
<p>使用函数匹配规则，例如StrVec的拷贝构造可以接受任何转换成StrVec的类型，而移动构造只能接受实参是非static右值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StrVec v1,v2;</span><br><span class="line">v1=v2;<span class="comment">//v2是左值，调用的是拷贝赋值</span></span><br><span class="line"><span class="function">StrVec <span class="title">getVec</span><span class="params">(istream &amp;)</span></span>;<span class="comment">//假设我们定义了这个函数</span></span><br><span class="line">v2=getVec(<span class="built_in">cin</span>)<span class="comment">//getVec返回的是非引用类型，是右值，因此调用移动构造函数</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>类有拷贝构造函数，没有移动构造函数：</li>
</ol>
<p>如果一个类定义了拷贝构造函数，没有移动构造函数，编译器不会合成移动函数的。此时，右值也能通过拷贝构造函数拷贝，因为右值引用可以转换成给一个const左值引用，拷贝函数代替移动构造几乎是安全的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">                Foo()=<span class="keyword">default</span>;</span><br><span class="line">                Foo(<span class="keyword">const</span> Foo&amp; )&#123;<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Foo copy construct"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        Foo x;</span><br><span class="line">        <span class="function">Foo <span class="title">y</span><span class="params">(x)</span></span>;</span><br><span class="line">        <span class="function">Foo <span class="title">z</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(x))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序即使调用move返回一个右值引用但还能使用拷贝拷贝构造</p>
<p>移动赋值运算符和拷贝赋值运算符的调用情况类似</p>
<h5 id="移动迭代器"><a href="#移动迭代器" class="headerlink" title="移动迭代器"></a>移动迭代器</h5><p>StrVec的reallocate使用循环方式，我们可以采用另外一种方式：uninitialized_copy+移动迭代器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">            alloc.construct(dest++,<span class="built_in">std</span>::<span class="built_in">move</span>(*elem++));</span><br><span class="line">            <span class="comment">//construct函数 在未构造的内存构造对象</span></span><br><span class="line">  &#125;<span class="comment">//旧版</span></span><br><span class="line">  uninitialized_copy(make_move_iterator(<span class="built_in">begin</span>()),make_move_iterator(<span class="built_in">end</span>()),dest);<span class="comment">//新版</span></span><br></pre></td></tr></table></figure>

<p>uninitialized_copy对序列中每个元素调用construct，对移动迭代器解引用生成的是一个右值引用，construct将使用移动构造函数来构造元素</p>
<h5 id="成员函数通过右值引用提供移动版本"><a href="#成员函数通过右值引用提供移动版本" class="headerlink" title="成员函数通过右值引用提供移动版本"></a>成员函数通过右值引用提供移动版本</h5><p>为StrVec类增加push_back()的移动版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;&amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line">    check_alloc();</span><br><span class="line">    alloc.construct(first_free++,<span class="built_in">std</span>::<span class="built_in">move</span>(s));</span><br><span class="line">&#125;</span><br><span class="line">p.push_back(<span class="string">"string1"</span>);<span class="comment">//会调用移动版本</span></span><br><span class="line"><span class="built_in">std</span>::stirng s=<span class="string">"string2"</span>;</span><br><span class="line">p.push_back(s);<span class="comment">//调用拷贝版本</span></span><br></pre></td></tr></table></figure>




      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/cpp/" rel="tag"># cpp</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/06/14/%E4%BB%8E%E9%9B%86%E5%90%88%E7%9C%8BDP/" rel="next" title="从集合看DP">
                <i class="fa fa-chevron-left"></i> 从集合看DP
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Wentao Yung</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#拷贝构造函数"><span class="nav-number">1.</span> <span class="nav-text">拷贝构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#合成拷贝构造函数"><span class="nav-number">1.1.</span> <span class="nav-text">合成拷贝构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#拷贝初始化"><span class="nav-number">1.2.</span> <span class="nav-text">拷贝初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#拷贝构造函数的形参"><span class="nav-number">1.3.</span> <span class="nav-text">拷贝构造函数的形参</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拷贝赋值运算符"><span class="nav-number">2.</span> <span class="nav-text">拷贝赋值运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#析构函数"><span class="nav-number">3.</span> <span class="nav-text">析构函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#析构函数的工作"><span class="nav-number">3.1.</span> <span class="nav-text">析构函数的工作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#什么时候调用析构函数"><span class="nav-number">3.2.</span> <span class="nav-text">什么时候调用析构函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#合成析构函数"><span class="nav-number">3.3.</span> <span class="nav-text">合成析构函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三-五法则"><span class="nav-number">4.</span> <span class="nav-text">三&#x2F;五法则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-default-和-delete"><span class="nav-number">5.</span> <span class="nav-text">使用&#x3D;default 和&#x3D;delete</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拷贝控制和资源管理"><span class="nav-number">6.</span> <span class="nav-text">拷贝控制和资源管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#行为像值的类"><span class="nav-number">6.1.</span> <span class="nav-text">行为像值的类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#行为像指针的类"><span class="nav-number">6.2.</span> <span class="nav-text">行为像指针的类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#交换操作"><span class="nav-number">7.</span> <span class="nav-text">交换操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态内存管理类"><span class="nav-number">8.</span> <span class="nav-text">动态内存管理类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#移动对象"><span class="nav-number">9.</span> <span class="nav-text">移动对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#右值引用"><span class="nav-number">9.1.</span> <span class="nav-text">右值引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#标准库move-函数"><span class="nav-number">9.2.</span> <span class="nav-text">标准库move 函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#移动构造函数和移动赋值运算符"><span class="nav-number">9.3.</span> <span class="nav-text">移动构造函数和移动赋值运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#合成的移动构造函数和移动赋值运算符"><span class="nav-number">9.4.</span> <span class="nav-text">合成的移动构造函数和移动赋值运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#什么时候调用移动构造函数和移动赋值运算符"><span class="nav-number">9.5.</span> <span class="nav-text">什么时候调用移动构造函数和移动赋值运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#移动迭代器"><span class="nav-number">9.6.</span> <span class="nav-text">移动迭代器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#成员函数通过右值引用提供移动版本"><span class="nav-number">9.7.</span> <span class="nav-text">成员函数通过右值引用提供移动版本</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wentao Yung</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
